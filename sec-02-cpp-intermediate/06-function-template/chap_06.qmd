---
title: "Function template"
# subtitle: "Control Flow"
author: |
    Khiem Nguyen 
    <br>Lecturer in Multiscale Materials
    <br><khiem.nguyen@glasgow.ac.uk>
author-meta: "Lecturer in Multiscale Materials"
format: 
    revealjs:
        theme: simple   # other themes: beige, blood, dark, dracula, league, moon, night, serif, simple, sky, solarized
        mouse-wheel: true
        # chalkboard: true
        highlight-style: github
        slide-number: true
        title-slide-style: pandoc
        echo: true
        code-overflow: wrap
        code-line-numbers: true
        code-block-bg: false          # <-- remove white background in code blocks
        # code-block-border-left: false # optional: remove left border
        # highlight-style: monokai      # good for dark images
        toc: true
        toc-depth: 1
        toc-title: Presentation Outline
        css: simple.css
---

# Introduction to template

## We saw the use template in the lab assignments

We saw the use of template already: 

- `std::vector<double>`
- `std::vector<int>`

Other examples of template classes:

- `std::list<std::string>`
- `std::map<str::string, map>`

Other examples of template functions:

- `std::max(1, 2)   // input arguments: int and int; compiler understands`
- `std::max<double>(10, 42.24) // to treat both as doubles`

ðŸ˜Œ I hope it's pretty natural to understand what these data types mean.

## Rationale for template

- Let us consider a function to find the maximum of two numbers:
```{.cpp}
int max(int x, int y)
{ 
    return (x < y) ? y : x; // Note: we use < instead of > because std::max uses <
}
```
- So what happens later when you want to find the max of two double values? The solution is to create a new overloaded version of `max`
```{.cpp}
double max(double x, double y)
{
    return (x < y) ? y: x;
}
```

:::{.fragment}
Now, the problem arises here. What about many different data types: `int`, `double`, `long`, `long double` and so on?
:::
:::{.fragment}
Fortunately, C++ supports another feature that was designed specifically to solve this kind of problem: C++ templates
:::

## Intro to C++ template

Before explaining the template, let us consider the following code snippet:

```{.cpp}
T max(T x, T y) // won't compile because we haven't defined T
{
    return (x < y) ? y : x;
}
```
- We wish that `T` can be any data type so that the comparison `x < y` makes sense.
- How nice it is if this piece of code can compile and give us what we expected.

## Intro to C++ template

**Template** 

::: {.incremental}
- To simplify the process of creating functions/classes that are able to work with different data types.
- To create a _single template_ instead of a bunch of mostly-identical functions/classes.
- To Provide a _placeholder type_ representing some type that is not known at the time the template is defined.
- To generate as many overloaded functions/classes as needed
:::

In the rest of this chapter, we explore how to create **function templates**.

# Function templates

## Terminologies: About function templates

::: {.incremental}
- A **function template** is a function-like definition that is used to generate one or more overloaded functions, each with a different set of actual types.
- The initial function template that is used to generate other functions is called the **primary template**.
- The functions generated from the primary template are called **instantiated functions**.
- When we create a _primary function template_, we use placeholder types, technically called **type template parameters**, informally called **template types**.
:::

## Creating a function template

Recall out `max()` function
```{.cpp}
int max(int x, int y)
{
    return (x < y) ? y : x;
}
```

Our wishful piece code
```{.cpp}
T max(T x, T y)     // won't compile because we haven't defined T
{
    return (x < y) ? y : x;
}
```

We need

- to tell the compiler that this is a template, and that `T` is a _type template parameter_. 
- to use a **template parameter declaration**.

## Use template parameter declaration

Each function template/class template needs its own **template parameter declaration**.

```{.cpp}
// this is the template parameter declaration 
// defining T as a type template parameter
template <typename T> 
T max(T x, T y)     // this is the function template definition for max<T>
{
    return (x < y) ? y : x;
}
```

**Summary**  

- Start with the keyword `template`.
- Use keyword `typename` (preferred) or `class`, followed by the name of the type template parameter (e.g. `T`).


# Naming convention of template parameters

## Naming template parameters

**Naming convention**

- Use a single capital letter (starting with T) when the template parameter is used in a trivial or obvious way.
- No need to give T a complex name, because itâ€™s obviously just a placeholder type.

```{.cpp #lst-template-function-conventional-naming lst-cap="Use template naming convention"}
template <typename T>
T max(T x, T y)
{
    return (x < y) ? y : x;
}
```

```{.cpp #lst-template-function-nonconventional-naming lst-cap="Use whatever name you like"}
template <typename Bullshit>
Bullshit max(Bullshit x, Bullshit y)
{
    return (x < y) ? y : x;
}
```

## Naming template parameters

For non-obvious usage o specific requirements, there are two common naming conventions:

- Starting with a capital letter (e.g. `Allocator`). _The standard library uses this naming convention_.
- Prefixed with a `T`, then starting with a capital letter (e.g. `TAllocator`).

> **Best practice to use**
>
> Use a single capital letter starting with `T` (e.g., `T`, `U`, `V`, etc.) to name type template parameters that used in trivial or obvious ways.


# Function template instantiation

We learn how function templates are used.

## Using a function template

**About function template**

- Function templates are not actually functions. 
- Their code is not compiled or executed directly.
- Function templates are used to generate functions that are compiled and executed.

**Use function template**

- Make a function call with the syntax
  
    ```{.cpp}
    // actual_type is some actual type, like int or double
    max<actual_type>(arg1, arg2); 
    ```
- The type in angled brackets is called **template argument**.

## Using a function template

::: {#lst-use-template-function lst-cap="An example of using template function &ndash; Filename: `use_template_function.cpp`"}
```{.cpp}
{{< include ./cpp/use_template_function.cpp >}}
```
:::
- When the compiler encounters `max<int>(1, 2)`, it determines that a function definition for `max<int>(int, int)` does not already exist.
- The compiler will implicitly use `max<T>` function template to create one.

## Function template instantiation

### Terminologies

::: {.incremental}
- The process of creating functions (with specific types) from function templates (with template types) is called **function template instantiation**.
- When a function is instantiated due to a function call, itâ€™s called **implicit instantiation**.
- A function that is instantiated from a template is technically called a **specialization**, but in common language is often called a **function instance**.
- The template from which a **specialization** is produced is called a **primary template**.
- _Function instances are normal functions in all regards._
:::

::: {.fragment}
> **Remember**
>
> Function template is not a function. It helps to create functions.
:::

## Function template instantiation

**Process for instantiating a function**  

The compiler essentially clones the primary template and replaces the template type (`T`) with the actual type we have specified.

- When we call `max<int>(1, 2)`, the function specialization that gets instantiated looks like

```{.cpp}
template<> // ignore this for now
int max<int>(int x, int y) // the generated function max<int>(int, int)
{
    return (x < y) ? y : x;
}
``` 

## Function template instantiation
What the compiler actually compiles after all the instantiation are done:

```{.cpp}
{{< include ./cpp/instantiation_look.cpp >}}
```

Let us compile it and run to see.
