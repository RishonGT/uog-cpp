---
title: "Function template"
subtitle: "Function templates with multiple template types"
author: |
    Khiem Nguyen 
    <br>Lecturer in Multiscale Materials
    <br><khiem.nguyen@glasgow.ac.uk>
author-meta: "Lecturer in Multiscale Materials"
format: 
    revealjs:
        theme: simple   # other themes: beige, blood, dark, dracula, league, moon, night, serif, simple, sky, solarized
        mouse-wheel: true
        highlight-style: github
        slide-number: true
        title-slide-style: pandoc
        echo: true
        code-overflow: wrap
        code-line-numbers: true
        code-block-bg: false          # <-- remove white background in code blocks
        # code-block-border-left: false # optional: remove left border
        # highlight-style: monokai      # good for dark images
        toc: true
        toc-depth: 1
        toc-title: Presentation Outline
        chalkboard: true
        css: simple.css
---

# Introduction

## Rationale

&#10149; Let us look at the example:
```{.cpp}
#include <iostream>

template <typename T>
T max(T x, T y) {
    return (x < y) ? y : x;
}
int main()
{
    std::cout << max(2, 3.5) << '\n';  // compile error

    return 0;
}
```

&#10149; The compiler will issue a bunch of (probably crazy looking) error messages.

**Question** Can somebody explain why?

## Rationale

We can fix the above issue as
```{.cpp}
#include <iostream>

template <typename T>
T max(T x, T y)
{
    return (x < y) ? y : x;
}

int main()
{
    // we've explicitly specified type double, so the compiler won't use template argument deduction
    std::cout << max<double>(2, 3.5) << '\n';

    return 0;
}
```

&#10140; It would be even nicer if we didnâ€™t even have to think about the types when making a function call to max at all.

# Function templates with multiple template type parameters

## Function templates with multiple template type parameters
- **Root or problem**: 
  - defined the single template type (`T`) for our function template
  - specified that both parameters must of the same type
- Rewrite our function template in such a way that our parameters can resolve to different types.

```{.cpp}
{{< include ./cpp/two_template_type_parameters.cpp >}}
```

&#10140; The compiler can instatiate `max<int, double>(int, double)` for executing `max(2, 3.5)`.

## Function templates with multiple template type parameters
```{.cpp}
{{< include ./cpp/two_template_type_parameters.cpp >}}
```
&#10149; Let us run the snippet and see the outcome.

:::{ .fragment}
**Question**&nbsp; Why do you see you you saw?
:::

:::{ .fragment}
**Question**&nbsp; How do we resolve the above issue?
:::

## Function templates with multiple template type parameters
&#10140; We let the compiler deduce what the return type should be by using `auto`

::: {#lst-two-template-parameters-return-auto lst-cap="Let the compiler deduce the return type using `auto`. Filename=`two_template_type_parameters_auto.cpp`"}
```{ .cpp}
{{< include ./cpp/two_template_type_parameters_auto.cpp >}}
```
:::

&#10149; Let us compile and run the code.

## Using `std::common_type_t`

- `std::common_type_t` is a metafunction used to determine the **single type of which all passed types can be implicitly converted**
- Need `#include <type_traits>`

**Basic Examples**

Type passed     | Resulting `std::commont_type_t` | Reason
:----------------|:--------------------|:-----------------------------------------------
`int` and `double` | `double` | `int` promotes to `double` without losing precision
`int` and `long` | `long` | Standard integer promotion rules 
`Derived1` and `Derived2` | `Base` | If both inherit from the same base, the base is the common type

## Using `std::common_type_t`
::: {#lst-two-template-parameters-return-auto lst-cap="An example of using `std::common_type_t`. Filename=`using_commont_type_t.cpp`"}
```{ .cpp}
{{< include ./cpp/using_common_type_t.cpp >}}
```
:::

- It is fine to use `auto` with the help of recent compilers.

# An introduction to `auto` keyword

## Keyword `auto`

::: {.incremental}
- The `auto` keyword is one of the most transformative features of modern C++.^[Well, I started to learn C++ when C++ was not modern.]
- At its core, `auto` tells the compiler to **deduce** the type of a variable from its initializer.
- Instead of manually typing out ocmplex type names, the compiler looks at what is on the right side of the `=` sign and figures it out for you at compile time.
- This does not make C++ "dynamically typed" like Python.
- The type is still fixed once the compiler determines it, ensuring your code remains fast and type-safe.
:::

::: {.fragment}
**Examples**
```{.cpp}
auto age = 25;              // int
auto price = 42.99;         // double
auto greeting = "Hello";    // const char*
std::string name = "Khiem Nguyen";
auto my_name = name;        // std::string
```
:::

## Keyword `auto`

&#10149; One nuance involves **type modifiers** like `const` and references (`&`). By default, `auto` drops these.

For examples:

- If we have a `const int`, plain `auto` will just deduce an `int`
- If we want to keep the const-ness or make it a reference, we have to be explicit.

```{.cpp}
const int constant_val = 10;
auto x = constant_val;       // x is just an 'int' (a copy)
const auto y = constant_val; // y is 'const int'
auto& z = constant_val;      // z is 'const int&' (a reference)
```

::: {.fragment}
> **Remark**
>
> Don't worry: _We will learn reference soon in the next chapter_.
:::

## Abbreviated function 

- The `auto` keyword became a cornerstone of modern programming in 2011 with the release of C++11.

> C++20 introduces a new use of the `auto` keyword: When the `auto` keyword is used as a parameter type in a normal function, the compiler will automatically convert the function into a function template with each `auto` parameter becoming an independent template type parameter.

**Example**

```{.cpp}
auto max(auto x, auto y)
{
    return (x < y) ? y : x;
}
```

is shorthand in C++20 for the following
```{.cpp}
template <typename T, typename U>
auto max(T x, U y)
{
    return (x < y) ? y : x;
}
```

## Function templates may be overloaded

- Function templates can also be overloaded.
- Such overloads can have a different number of template types and/or a different number or type of function parameters.

## Function templates may be overloaded

::: {#lst-function-templates-overloaded lst-cap="Function templates can be overloaded. Filename=`function_templates_overloaded.cpp`"}
```{ .cpp}
{{< include ./cpp/function_templates_overloaded.cpp >}}
```
:::